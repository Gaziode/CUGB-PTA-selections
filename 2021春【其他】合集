头文件
<cstdio>/<stdio.h>
<iostream>
<cmath>
<iomainip>
<cstdlib>+using
<stdlib.h>

(a>b?a:b)
cout<<setiosflags(ios::fixed)<<setprecision(2);
pow(a,^n)
int rand()%(n-1)
void strand(unsigned int)//time 返回
带空格的字符串输入：cin.getline(数组名称,字符数量)或get(x,x)（PTA不适用）
保留1位小数的提示：
如果使用cout输出时，需要包含std命名空间中的iomanip，然后使用fixed和setprecision组合而成，如： cout << setiosflags(ios::fixed) << setprecision(1) << F; 或： cout << fixed << setprecision(1) << F;
如果使用printf，代码比较比较简洁高效，需要包含stdio.h，然后使用格式控制字符串%.1lf表示输出一个保留1位小数的double型值，如： printf("%.1f",F);
cout<<setw()<<a<<endl//C++设置输出行数

//选择
编写C++程序一般需经过的几个步骤依次是【 】。
B、编辑、编译、连接、运行

C++语言编译程序的首要工作是【 】。
A、检查C++语言程序的语法错误 

下列选项中，全部都是C++合法用户标识符的是【】。
→标识符可以由大写字母、小写字母、下划线（_）和数字0~9组成，但必须是以大写字母、小写字母或下划线（_）开头

执行下面程序段,给x、y赋值时,不能作为数据分隔符的是 【】。
 int x,y;
 cin>>x>>y;
D、逗号

设以下变量均为整型，则值不等于7的表达式是【C】。
A、(x=y=6, x+y, x+1)
B、(x=y=6, x+y, y+1)
C、(x=6, x+1, y=6, x+y)
D、(y=6, y+1,x=y, x+1)
→逗号表达式的值等于最后一个逗号右边的子表达式,但这个字表达式可以被前面的字表达式影响

设有:int a=1,b=2,c=3,d=4,m=2,n=2;
执行(m=a>b)&&(n=c>d)后n的值为【】。
C、2

当int a=3,b=2,c=1,f 时,表达式f=a>b>c的值是【  0  】。
→因为f=a>b>c可以写成f=((a>b)>c)，a>b是3>2为真，值为1；然后1>c是1>1为假，值为0；最后赋值给f，所以f=0。

下面不正确的说法是：
C、形参与其对应的实参类型可以不一致
→形参不能是常量，也不能是表达式

下列关于C++函数的说明中，正确的是【】。
C、编译器会根据函数的参数个数和参数类型来区分函数的重载形式

在下列关于设置参数默认值的各种描述中，正确的是【】。
B、设置参数默认值时，应该是先设置右边的再设置左边的

下面说法中正确的是：如果在一个函数中的复合语句中定义了一个变量，则该变量【】。
D、只在该复合语句中有效

函数是有函数头和 【函数体】。

C++语言中，函数直接或间接调用函数本身，则该函数称为【递归】函数。

执行语句for(i=1;i++<4;);之后,变量i的值为【 】。
D、5

在C/C++语言中,数组的首元素的地址是【数组名】。

下面说法中正确的是
A、字符个数多的字符串比字符个数少的字符串大
B、字符串“That”小于字符串“The”
C、两个字符串所包含的字符个数相同时,才能比较字符串
D、字符串“STOP□”与“STOP”相等(□表示空格)
正确答案： B

判断字符串s1是否大于字符串s2,应当使用
D、if (strcmp (s1,s2)>0)

下面程序段的运行结果是【】。(其中□表示空格) 
char c[5]={ 'a', 'b', '\0', 'c', '\0'}; 
cout<<c;
B、ab

阅读下面的数组定义,正确的说法是:
char sa[ ]="abcdefg"; 
char sb[ ]={'a', 'b', 'c', 'd', 'e', 'f', 'g'};
C、数组sa的长度大于数组sb的长度

下面对C++语言字符数组的描述中错误的是
A、字符数组可以存放字符串
B、可以在赋值语句中通过赋值运算符等号对字符数组整体赋值
C、字符数组中的字符串可以整体输入、输出
D、不可以用关系运算符对字符数组中的字符串进行比较
正确答案： B 

字符串处理函数strlen(s)是返回字符串s的长度len,最后一个字符可表示为s[len-1]。

操作文件要包含的头文件是________。
D、fstream

若fp是指向某文件的指针,且已读到文件末尾,则库函数fp .eof()的返回值是【true】。
C、true

C++中，文件操作完成后必须进行关闭，断开文件流与文件的联系，保证将缓冲区中的数据写入到文件中。假如打开文件流对象ifs，则关闭使用ifs.close()方法。

如果要读写二进制文件，需要将文件的打开方式设置为【binary或ios::binary】。

读取文件时，必须保证文件存在，如果不存在，文件流为空。
假如有下面代码段，请填空：
ifsteam  ifs;        //创建输入流对象
ifs.open("data1.dat");     //打开当前目录的data1.dat文件
if(【!ifs或ifs==NULL】)   
  {     cout << "File not Exist!";
        return(1);
 }

在C/C++语言的数据文件，是由若干个字符（字节）按顺序组成的，包括文本文件和【二进制】文件。

下列关于类和对象的叙述中，错误的是_____。
A、类是对某一类对象的抽象
B、对象是类的具体实例
C、类和对象的关系是一种数据类型和变量的关系
D、一个类只能有一个对象
正确答案： D 

有关类性质说法错误的是_____。
A、析构函数和构造函数都不能有返回类型
B、一个类中不可以声明具有类类型的数据成员
C、不能给析构函数指定参数
D、一个类可以有多个构造函数，但只有一个析构函数
正确答案： B 

已知类声明如下“class A{ int a;};”，则类A的数据成员a的访问权限是_____。
C、private

已知A是一个类，下面语句执行时会调用【   】次A类的构造函数。
A  a[2];
A b;
A &p = b;
B、3

C++中，系统自动为一个类生成默认构造函数的条件是该类没有自定义任何_____。
B、构造函数

当一个类对象生命期结束时，系统自动调用_____并销毁对象。
D、析构函数

当创建一个类对象时，系统自动调用_____实现对象的数据成员的初始化。
A、构造函数

若有以下定义：char s[10]= "include",*p=s; ，则不能代表字符‘u’的表达式为【   】。
A、s[4]
B、s+4
C、*(p+4)
D、p+=4,*p

若已有float *p, m=3.14; 要让p指向m，正确的赋值语句是【   】。
D、p = &m;

下面对于指针变量p的操作正确的是【   】
C、int a=5, *p;
p=&a;

下面函数中，无法实现主调函数交换两个整数的值的功能的是【   】。
A、fun2(int& x, int& y)
{
          int temp = x;
          x = y;
          y = temp;
     }

B、fun3(int* x,int* y)
     {
         int temp = *x;
         *x = *y;
         *y = temp;
     }

C、fun4(int* x, int* y)
      {
         int* temp=new int;
         *temp = *x;
         *x = *y;
         *y = *temp;
    }

D、fun1(int x,int y)
      {
           int temp=x;
           x = y;
           y = temp;
     }

下面程序的输出结果是【 】。
int fun(int x,int y,int *cp,int *dp) //函数定义,形参
{   *cp=x+y; 
    *dp=x-y;
}
int main()
{   int a, b, c, d;
    a=30; b=50;
    fun(a,b,&c,&d);    //函数调用,实参
    cout<<c<<”,”<<d<<endl;
    return 0;
}
A、80,-20

下面对于指针变量的操作，错误的是【   】。
A、int a, *p=&a;
B、int a, &p;  *p=a;
C、int a, *p;  p=&a;
D、int a; int *p=&a;

下面的new用法正确的是【   】。
A、int *p = new int(5);

在C++中，可以使用new运算符动态地分配内存，并将地址保存到指针变量，就可以通过指针变量访问该内存，实现在程序运行中根据需要动态分配指定大小的空间。
如果要动态分配一个包含10个int型的连续内存单元，下面写法正确的是【   】。
B、int *p= new int[10];

已知语句:
    int *p = new int[5];
下面的delete用法正确的是【   】。
D、delete[] p

假设有类A定义如下：
class A
{
public:
    A(int m);
    A  T();
private:
     int m;
};
在类的成员函数中允许使用类的数据成员。隐含当前对象的指针是this，下面几个对于this的操作，正确的是【   】。
（1）A::A(int m)
       { 
            this->m = m; 
        }
（2）A::A(int m) 
       { 
              this.m = m; 
        }
（3）A  A::T() 
       { 
          m++;  
           return *this;
       }
（4）A  A::T() 
       { 
               m++;  
               return this; 
        }
（5）A  A::T()  
        {
                m++; 
                return T; 
         }  
B、（1）和（3）

C++中，对于对象，可以通过句点运算符“.”来访问其公有成员。对于指针变量，也可以通过指向运算符【->】访问指向对象的公有成员。

C++中，要释放用new分配的空间，应该用【delete】运算符。

定义一个指针变量p,指向堆heap中一个10数的整型数组
int *p=【new int[10]】;
释放这些内存的语句是【delete []p】; 

函数重载是指【   】。
A、两个或两个以上的函数取相同的函数名，但形参的个数或类型不同

下面函数的功能为【】。 
 void swap(int *p1,int *p2) 
{  int t;   
    t=*p1; *p1=*p2; *p2=t; 
 }
A、交换*p1和*p2的地址
B、交换*p1和*p2的值
C、可能造成系统故障,因为使用了空指针
D、正确,但无法改变*p1和*p2的值

while和do…while语句的主要区别是【 】。

D.do…while的循环体至少要无条件执行一次，而while可能一次都不执行

char s[5]="asdf";这句不是赋值而是初始化；讲的赋值语句是在程序执行中的赋值，就像
int a;
int b;
b=a;  这是赋值；对于字符而言，要赋值就要采用strcpy（s1，s2）这个函数。

在 C 语言中，字符串实际上是使用 null 字符 \0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。
字符串相关函数：
cin.getline() 是在输入一段字符完成后开始读取数据（注意，是输入完成后，以Enter为结束标志）
Instance: cin.getline(X,N)
'' 里面只能放一个字符;
"" 里面表示是字符串系统自动会在串末尾补一个 0。


strcpy(s1, s2);
复制字符串 s2 到字符串 s1。
strcat(s1, s2);
连接字符串 s2 到字符串 s1 的末尾。
strlen(s1);
返回字符串 s1 的长度。
strcmp(s1, s2);
（比较）如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。(如果两个字符串不匹配，且第一个字符串的第一个字符小于第二个字符串的第一个字符，才会返回比0小的值，反之则返回比0大的值)
strchr(s1, ch);
返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
strstr(s1, s2);
返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。

相关头文件：#include <cstring>/#include <string>



Instance:
class Box
{
   public:
      double length;   // 长度
      double breadth;  // 宽度
      double height;   // 高度
      // 成员函数声明
      double get(void);
      void set( double len, double bre, double hei );
};
// 成员函数定义
double Box::get(void)
{
    return length * breadth * height;
}
 
void Box::set( double len, double bre, double hei)
{
    length = len;
    breadth = bre;
    height = hei;
}
int main( )
{
   Box Box1;        // 声明 Box1，类型为 Box
   Box Box2;        // 声明 Box2，类型为 Box
   Box Box3;        // 声明 Box3，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   // box 1 详述
   Box1.height = 5.0; 
   Box1.length = 6.0; 
   Box1.breadth = 7.0;


C++ 类成员函数
类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。
成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义

C++ 类访问修饰符
一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。
公有（public）成员
公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值
私有（private）成员
私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。
默认情况下，类的所有成员都是私有的。例如在下面的类中。width 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员。
protected（受保护）成员
protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。

C++ 类构造函数 & 析构函数
类的构造函数
类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。
构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。
类的析构函数
类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。
析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。


要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>
下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。
void open(const char *filename, ios::openmode mode);
在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。

关闭文件
当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。

下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。

void close();
写入文件
在 C++ 编程中，我们使用流插入运算符（ << ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。

读取文件
在 C++ 编程中，我们使用流提取运算符（ >> ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。

读取 & 写入实例
下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：

实例
#include <fstream>
#include <iostream>
using namespace std;
 
int main ()
{
    
   char data[100];
 
   // 以写模式打开文件
   ofstream outfile;
   outfile.open("afile.dat");
 
   cout << "Writing to the file" << endl;
   cout << "Enter your name: "; 
   cin.getline(data, 100);
 
   // 向文件写入用户输入的数据
   outfile << data << endl;
 
   cout << "Enter your age: "; 
   cin >> data;
   cin.ignore();
   
   // 再次向文件写入用户输入的数据
   outfile << data << endl;
 
   // 关闭打开的文件
   outfile.close();
 
   // 以读模式打开文件
   ifstream infile; 
   infile.open("afile.dat"); 
 
   cout << "Reading from the file" << endl; 
   infile >> data; 
 
   // 在屏幕上写入数据
   cout << data << endl;
   
   // 再次从文件读取数据，并显示它
   infile >> data; 
   cout << data << endl; 
 
   // 关闭打开的文件
   infile.close();
 
   return 0;
}

打开文件
您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：

FILE *fopen( const char * filename, const char * mode );
在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：

模式	描述
r	打开一个已有的文本文件，允许读取文件。
w	打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。
a	打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。
r+	打开一个文本文件，允许读写文件。
w+	打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。
a+	打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。
如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：

"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"
关闭文件
为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：

 int fclose( FILE *fp );
如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。

C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。

写入文件
下面是把字符写入到流中的最简单的函数：

int fputc( int c, FILE *fp );
函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：

int fputs( const char *s, FILE *fp );
函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, ...) 函数把一个字符串写入到文件中。尝试下面的实例：

注意：请确保您有可用的 tmp 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。

/tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\tmp、D:\tmp等。

实例
#include <stdio.h>
 
int main()
{
   FILE *fp = NULL;
 
   fp = fopen("/tmp/test.txt", "w+");
   fprintf(fp, "This is testing for fprintf...\n");
   fputs("This is testing for fputs...\n", fp);
   fclose(fp);
}
当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 test.txt，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。

读取文件
下面是从文件读取单个字符的最简单的函数：

int fgetc( FILE * fp );
fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面的函数允许您从流中读取一个字符串：

char *fgets( char *buf, int n, FILE *fp );
函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。

如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 int fscanf(FILE *fp, const char *format, ...) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。

二进制 I/O 函数
下面两个函数用于二进制输入和输出：

size_t fread(void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
              
size_t fwrite(const void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
这两个函数都是用于存储块的读写 - 通常是数组或结构体。

可使用 & 运算符访问的地址，它表示了在内存中的一个地址。

指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

type *var-name;
在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。

不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

如何使用指针？
使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

实例
#include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
 
   printf("var 变量的地址: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("ip 变量存储的地址: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("*ip 变量的值: %d\n", *ip );
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

var 变量的地址: 0x7ffeeef168d8
ip 变量存储的地址: 0x7ffeeef168d8
*ip 变量的值: 20
C 中的 NULL 指针
在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。

NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：

实例
#include <stdio.h>
 
int main ()
{
   int  *ptr = NULL;
 
   printf("ptr 的地址是 %p\n", ptr  );
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：

ptr 的地址是 0x0
在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

如需检查一个空指针，您可以使用 if 语句，如下所示：

if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */
C 指针详解
在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：

C 指针的算术运算
C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。

假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

ptr++
在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。

我们概括一下：

指针的每一次递增，它其实会指向下一个元素的存储单元。
指针的每一次递减，它都会指向前一个元素的存储单元。
指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。

C 指针数组

下面是一个指向整数的指针数组的声明：

int *ptr[MAX];
在这里，把 ptr 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。
